{"name":"Meteor-React-TypeScript Todos","tagline":"A conversion of the Meteor-React sample app to use TypeScript","body":"### So you want to use Meteor, React, and TypeScript\r\n\r\nGreat choice! These are all fine technologies. Who wouldn't want to combine the end-to-end clarity of Meteor, the clear data flow of React, and the safety and comfort of TypeScript. You might be thinking this will be easy. After all, the official Meteor page has a [tutorial for combining Meteor and React](https://www.meteor.com/tutorials/react/creating-an-app) and there are established packages on Atmosphere for combining Meteor and TypeScript such as the meteortypescript [compiler](https://atmospherejs.com/meteortypescript/compiler) and [typescript-libs](https://atmospherejs.com/meteortypescript/typescript-libs) packages, so it looks like the work has already been done for us. Alas, in programming nothing is ever this easy, and there are quite a few obstacles to overcome along the way.\r\n\r\nA list of the problems we will need to solve:\r\n\r\n* We need a way to compile our .ts and .tsx files\r\n* We need type definitions for React and Meteor\r\n* Ideally, we want to use TypeScript namespaces to organize our code\r\n* We need a way to use the react-data-mixin with ES6-style React components\r\n* We need to reconcile the react-data-mixin with TypeScript typing\r\n\r\nEach of these problems has subtleties that require a bit of thought and experimentation to solve. Below are the solutions I came up with, the result of which can be seen at the linked GitHub project.\r\n\r\n### Compiling .ts and .tsx files\r\n\r\nI expected this step to be easy because the [meteortypescript:compiler](https://atmospherejs.com/meteortypescript/compiler) Meteor package seems like it solves this precise problem. However, meteortypescript:compiler seems only designed to convert .ts files. No matter what I tried, I could get it to correctly handle .tsx files: it would always leave the JSX elements in the compiled .js code. The documentation claims that compiler options can be given in a `.tsconfig` file at your project root, but even when I added the option `\"jsx\": \"react\"` it still incorrectly left JSX in .js files.\r\n\r\nSadly, this means finding our own means to compile the TypeScript files. I decided to use the [Atom](https://atom.io/) text editor with the [atom-typescript](https://atom.io/packages/atom-typescript) package, although I expect these steps will be similar with any other TypeScript IDE. I used atom-typescript to generate a `tsconfig.json` file (on a Mac, that's Cmd+Shift+P, then \"Create Tsconfig.json Project File\") and set the following options:\r\n\r\n    {\r\n        \"compilerOptions\": {\r\n            \"target\": \"es6\",\r\n            \"jsx\": \"preserve\",\r\n            \"experimentalDecorators\": true,\r\n            ...\r\n        },\r\n        ...\r\n        \"compileOnSave\": true,\r\n        \"buildOnSave\": true,\r\n        ...\r\n    }\r\n\r\nNow whenever we save a .ts or a .tsx file, a corresponding .js or .jsx file is automatically generated in the same directory. This does clutter up our directories somewhat, but it has benefits as well:\r\n\r\n* The TypeScript step of the build process is completely transparent, as we can see exactly what is being fed into Meteor and examine it if we choose to do so\r\n* The `filesGlob` option in the generated `tsconfig.json` automatically finds definitions for us. This eliminates the need to add reference declarations at the top of all our files, e.g.\r\n\r\n        /// <reference path=\"./typings/react/react.d.ts\" />\r\n\r\n* Since our IDE is responsible for building, we don't run into situations where the IDE insists things are correct while the build system fails or vice versa\r\n\r\nThe added .js and .jsx files are kind of annoying though, so let's see if we can hide them a bit. The first thing to do is have Git ignore them, since we don't want compiled files being committed. I create a `.gitignore` in my project root directory containing\r\n\r\n    **/*.js\r\n    **/*.jsx\r\n\r\nAssuming I have already run `git init`, Atom will now grey out all the gitignored .js and .jsx files in its tree view. Atom also has an option to hide gitignored files entirely, but as a personal preference I prefer to be able to see them so I can poke around in them if need be.\r\n\r\n### Type definitions for React and Meteor\r\n\r\nType definitions for React are easy. I have the [TSD definition manager](https://github.com/DefinitelyTyped/tsd) installed, so from the project root I type\r\n\r\n    tsd install react --save\r\n    tsd install react-global --save\r\n\r\nIf you don't use TSD, you can just as easily fetch the definitions from [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react).\r\n\r\nNow for the Meteor definitions. We could simply get these from TSD/DefinitelyTyped as well, and this is a fine solution. However, I decided to get these from the [meteortypescript:typescript-libs](https://atmospherejs.com/meteortypescript/typescript-libs) Meteor package. This has the advantage that the definitions will update automatically with `meteor update`, and it also comes with a handful of other definition files for common Meteor specific libraries that don't appear on DefinitelyTyped, such as [iron:router](https://atmospherejs.com/iron/router). It does take a little bit more work, so I will totally understand if you decide not to do it. But for those who want to try, we run\r\n\r\n    meteor add meteortypescript:typescript-libs\r\n\r\nand as suggested in the documentation (after running the project) add a symbolic link to the definitions deep within the `.meteor` directory:\r\n\r\n    ln -s ../.meteor/local/build/programs/server/assets/packages/meteortypescript_typescript-libs/definitions typings/package_defs\r\n\r\nHowever, this isn't perfect because it adds a bunch of definitions to libraries we may not be using or even have installed, like D3. Much more annoyingly, it contains a `lib.d.ts` file which contains the base JavaScript definitions which for some reason conflicts with TypeScript's built in definitions, causing build errors in our IDE. To solve both these problems, we'll make sure that the `typings/package_defs` directory is not compiled with the project by excluding it in `tsconfig.json`:\r\n\r\n    ...\r\n    \"filesGlob\": [\r\n        \"**/*.ts\",\r\n        \"**/*.tsx\",\r\n        \"!node_modules/**\",\r\n        \"!typings/package_defs/**\"\r\n    ],\r\n    ...\r\n\r\nThen to actually get the specific definitions we want from `typings/package_defs`, create a new definition file which explicitly references the desired files. I created a new file `typings/package_defs.d.ts` which for now just contains\r\n\r\n    /// <reference path=\"./package_defs/meteor.d.ts\" />\r\n\r\nDone! Try typing some React or Meteor expressions into a .ts or .tsx file now and hopefully get autocompletion and type information.\r\n\r\n### Using TypeScript namespaces\r\n\r\nThis step is optional and the solution is quite disgusting. You might decide you don't intend to use the namespace feature of TypeScript at all, in which case you can ignore this step and happily spew symbols into the global scope. But I happen to like namespaces a lot. Some advantages:\r\n\r\n* Exporting a single symbol into the global scope greatly reduces the possibility of naming conflicts with other libraries or future built-in functions\r\n* It is particularly useful when debugging because I can access all app specific names through the single global variable rather than autocompleting from the large pool of global names\r\n* It helps organize code by allowing simpler names in a given part of the code. For example, if I am in the namespace `Todos.Task`, I can declare a class named `State` representing the state of a Task and not worry about using up such a clear and generic name\r\n\r\nSo what makes namespaces hard to use with Meteor? We'll need to look into the implementation details of namespaces a bit. The TypeScript code\r\n\r\n    namespace Space {\r\n        export const x = 2;\r\n    }\r\n\r\ncompiles to the JavaScript\r\n\r\n    var Space;\r\n    (function (Space) {\r\n        Space.x = 2;\r\n    })(Space || (Space = {}));\r\n\r\nNeat right? It grabs an existing object with the namespace name out of global scope, and then exported variables are read from and written to that object. Unfortunately, in an effort to be helpful, Meteor wraps the contents of each file in an [IIFE](https://en.wikipedia.org/wiki/Immediately-invoked_function_expression), meaning what gets emitted actually looks like this\r\n\r\n    (function () {\r\n        var Space;\r\n        (function (Space) {\r\n            Space.x = 2;\r\n        })(Space || (Space = {}));\r\n    })();\r\n\r\nThis ruins everything, because now the `var Space` no longer references the global variable `Space` but instead declares a new one inside the scope of the newly added anonymous function. Since each reference to the namespace therefore refers to an entirely different object, the whole system comes crashing down.\r\n\r\nUnfortunately, I cannot come up with a clean solution to this problem, so I eventually settled on the solution proposed by Dr. Llama in the post [Meteor Typescript - Classes and Modules](https://doctorllama.wordpress.com/2015/04/21/meteor-typescript-classes-and-modules/) (in the linked post, Dr. Llama talks about \"modules\" instead of \"namespaces\", but they are the same concept). That is, we use `eval` to insert a line to make the variable refer to the global reference, e.g.\r\n\r\n    eval(\"var Space = this.Space || (this.Space = {})\");\r\n\r\n    namespace Space {\r\n        ...\r\n    }\r\n\r\nSince I'll be doing this a lot, I'll factor out that string into a helper function declared in a separate file that we make sure is loaded first:\r\n\r\n    \r\n    declare var namespaceEvalHack: (namespace: string) => string;\r\n\r\n    namespaceEvalHack = function namespaceEvalHack(namespace: string) {\r\n        return `var ${namespace} = this.${namespace} || (this.${namespace} = {})`;\r\n    }\r\n\r\nand then whenever we use namespaces we can write\r\n\r\n    eval(namespaceEvalHack(\"Space\"));\r\n\r\n    namespace Space {\r\n        ...\r\n    }\r\n\r\nWhew. It's pretty ugly, but it works and now we can use namespaces to our hearts' content.\r\n\r\n### Using ReactDataMixin with ES6 Components\r\n\r\nThe [Meteor react package](https://atmospherejs.com/meteor/react) provides a mixin called `ReactDataMixin` to allow the creation of React components that are reactive in the Meteor sense (i.e. update when collections update, etc.). Unfortunately, React mixins are not supported to be used with [ES6 style of component declaration](https://facebook.github.io/react/docs/reusable-components.html#es6-classes), which is the way supported by TypeScript. To reconcile the two, we need the help of a third-party library, [react-mixin](https://github.com/brigand/react-mixin), which allows React mixins to be used with ES6 classes. react-mixin comes in two versions, one from npm and one as a standalone library that exports the global symbol `reactMixin`. We will choose the second once, since incorporating our app with `npm` is a challenge for another day (if your curious, it can be done with Meteor's [cosmos:browserify](https://atmospherejs.com/cosmos/browserify) package). I save the standalone lib to `lib/thirdParty/react-mixin.js`.\r\n\r\nBut wait, didn't we tell Git to ignore all .js files in the project? That's inconvenient. To get around this, we'll add an exception for the specific directory we decide to use for third-party libs, by adding a line to our `.gitignore` so it appears\r\n\r\n    **/*.js\r\n    **/*.jsx\r\n    !lib/thirdParty/**\r\n\r\nAssuming you set `\"experimentalDecorators\": true` in your `tsconfig.json` as suggested above, we can now mix `ReactDataMixin` with our ES6 classes as follows:\r\n\r\n    @reactMixin.decorate(ReactDataMixin)\r\n    class SomeComponent extends React.Component<{}, {}> {\r\n        ...\r\n    }\r\n\r\nOr if you don't want to use decorators, you can do it instead with\r\n\r\n    class SomeComponent extends React.Component<{}, {}> {\r\n        ...\r\n    }\r\n\r\n    reactMixin.onClass(SomeComponent, ReactDataMixin);\r\n\r\nOf course, if you do this right now, TypeScript will start complaining everywhere. The typing story here is a little complicated, so let's jump into it!\r\n\r\n### Typings for ReactDataMixin\r\n\r\nNeither `ReactDataMixin` nor `reactMixin` seem to have existing type definitions. Luckily, both are simple enough that we can write the definitions ourselves without too much trouble.\r\n\r\nFirst things first: let's get a definition for `ReactDataMixin`. In a definition file somewhere (I used `typings/react-data-mixin/react-data-mixin.d.ts`), write\r\n\r\n    declare const ReactDataMixin: any;\r\n\r\nAlright, that was easy! How about `reactMixin`?\r\n\r\n    declare interface ReactMixin {\r\n        (componentPrototype: React.Component<any, any>, mixin: any): void;\r\n        onClass: (componentClass: React.ComponentClass<any>, mixin: any) => void;\r\n        decorate: (mixin: any) => ClassDecorator;\r\n    }\r\n\r\n    declare const reactMixin: ReactMixin;\r\n\r\nWoo! Are we done? Not quite. When `ReactDataMixin` is added to a component, it adds a new field `data` to the host component and expects us to implement a new method `getMeteorData()` which reads the data from some reactive data source. Since we can't add a new field to a component with definitions alone, we will actually create a new Component superclass for this, parameterized on the type of `data` as well as on the types of props and state:\r\n\r\n    class MeteorComponent<P, S, D> extends React.Component<P, S> {\r\n        public data: D;\r\n    \r\n        public getMeteorData(): D {\r\n            throw new Error(\"MeteorComponent subclass must implement getMeteorData()\");\r\n        }\r\n    }\r\n\r\nNow we can declare components which depend on Meteor reactive sources by subclassing this\r\n\r\n    @reactMixin.decorate(ReactDataMixin)\r\n    class App extends MeteorComponent<AppProps, AppState, AppData> {\r\n        public getMeteorData(): AppData {\r\n            ...\r\n        }\r\n\r\n        ...\r\n    }\r\n\r\nAnd we're done! That was the last hurdle, so now we can finally develop in peace.\r\n\r\n### Other gotchas\r\n\r\nThere are a few other stumbling blocks I ran into while working on this which are too small to discuss at length but are still worth mentioning.\r\n\r\n* If you choose not to use namespaces, then certain type names you use may collide with third-party definitions. For example, if you naively follow the [Meteor-React tutorial](https://www.meteor.com/tutorials/react/creating-an-app) and use TypeScript without namespaces, then you will run into a baffling error when your class `App` conflicts with the type `App` declared in `meteor.d.ts`. You can avoid this problem by renaming the class to something else (say `MyApp`) or by using namespaces.\r\n* Certain Meteor API's bind some special value to `this`. For example, following the tutorial the Accounts package expects you use `this.userId` to get the current userId in a publication function argument. When writing such a function, make sure not to use ES6 arrow functions but instead to write out the full `function () { ... }`, since arrow functions capture the current value of `this`.\r\n* Adding types for Meteor and React code is not too bad after everything we've been through above, but if you ever get stuck, look through the [linked GitHub repo](https://github.com/dphilipson/meteor-react-typescript-todos) for sample code.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}